// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "ctre/Phoenix.h"
#include "ElevatorConstants.h"

#include "Elevator.h"
#include "../RobotMap.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "../Commands/ElevatorTarget.h"
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

Elevator::Elevator() : frc::Subsystem("Elevator") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    elevatorMotor = RobotMap::elevatorElevatorMotor;
    elevatorBrake = RobotMap::elevatorElevatorBrake;
    elevatorLEDs = RobotMap::elevatorElevatorLEDs;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    elevatorMotor->SetInverted(true);
}

void Elevator::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        SetDefaultCommand(new ElevatorTarget());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

}

void Elevator::Periodic() {
	// Put code here to be run every loop
	//ElevatorExecute();


}


// Put methods for controlling this subsystem
// here. Call these from Commands.

void Elevator::Init(bool pid){
	// * * * * * CHANGE MOTOR AND SOLENOID IDS * * * * * * * * * *

	isPID = pid;
	/* lets grab the 360 degree position of the MagEncoder's absolute position */
	//int absolutePosition = elevatorMotor->GetSelectedSensorPosition(0) & 0xFFF; /* mask out the bottom12 bits, we don't care about the wrap arounds */
	/* use the low level API to set the quad encoder signal */
	//elevatorMotor->SetSelectedSensorPosition(absolutePosition, kPIDLoopIdx, kTimeoutMs);
	elevatorMotor->SetSelectedSensorPosition(0, kPIDLoopIdx, kTimeoutMs);

	/* choose the sensor and sensor direction */
	elevatorMotor->ConfigSelectedFeedbackSensor(FeedbackDevice::CTRE_MagEncoder_Relative, kPIDLoopIdx, kTimeoutMs);
	elevatorMotor->SetSensorPhase(true);
	//******************************CHANGE BACK TO TRUE**************************************

	/* set the peak and nominal outputs, 12V means full */
	elevatorMotor->ConfigNominalOutputForward(0, kTimeoutMs);
	elevatorMotor->ConfigNominalOutputReverse(0, kTimeoutMs);
	elevatorMotor->ConfigPeakOutputForward(1, kTimeoutMs);
	elevatorMotor->ConfigPeakOutputReverse(-1, kTimeoutMs);

	elevatorMotor->Set(ControlMode::Position,0);
	targetPos = 0;

	if(pid){
		/* set closed loop gains in slot0 */
		elevatorMotor->Config_kF(kPIDLoopIdx, 0, kTimeoutMs);
		elevatorMotor->Config_kP(kPIDLoopIdx, 0.07, kTimeoutMs);
		elevatorMotor->Config_kI(kPIDLoopIdx, 0, kTimeoutMs);
		elevatorMotor->Config_kD(kPIDLoopIdx, 0, kTimeoutMs);
	}
}

void Elevator::ElevatorGoToRevolutions(double newTargetPos){
	targetPos = newTargetPos;
	targetMode = true;
	frc::SmartDashboard::PutString("DB/String 1",std::to_string(targetPos));
}

void Elevator::ElevatorExecute(){
	double encoderValue = elevatorMotor->GetSelectedSensorPosition(0)/4096.0;
	frc::SmartDashboard::PutString("DB/String 0",std::to_string(encoderValue));
	//look for d-pad values
	int povValue = Robot::oi->getGamePad()->GetPOV(0);
	if (povValue == 270 && !incrementButtonDown){
		ElevatorMoveDown();
		incrementButtonDown = true;
	}
	else if (povValue == 90 && !incrementButtonDown){
		ElevatorMoveUp();
		incrementButtonDown = true;
	}
	else if (povValue == 0){
		targetMode = false;
		elevatorBrake->Set(false);
		frc::SmartDashboard::PutString("DB/String 8","brake off");
		elevatorMotor->Set(ControlMode::PercentOutput,0.8);
		isManualMoving = true;
	}
	else if (povValue == 180){
		targetMode = false;
		elevatorBrake->Set(false);
		frc::SmartDashboard::PutString("DB/String 8","brake off");
		elevatorMotor->Set(ControlMode::PercentOutput,-0.60);
		isManualMoving = true;
	}
	else if (povValue == -1){
		incrementButtonDown = false;
		if (!targetMode && isManualMoving && motorStopCount < 0){
			elevatorBrake->Set(true);
			frc::SmartDashboard::PutString("DB/String 8","brake on");
			isManualMoving = false;
			motorStopCount = 0;
		}
	}
	if(targetMode){
		ElevatorExecuteTarget();
	}
		// * * stop delay is 20ms*(maxStopCount-1)
	int maxStopCount = 8;
	if(motorStopCount >= maxStopCount){
		//stop motor
		elevatorMotor->Set(ControlMode::PercentOutput,0);
		motorStopCount = -1;
	}
	else if(motorStopCount >= 0){
		motorStopCount += 1;
	}
	PartyLight(isManualMoving || isTargetMoving, encoderValue);
}

void Elevator::ElevatorExecuteTarget(){
	SetPIDs();
	//process move
	double goThreshold = 1.5;
	double stopThreshold = 0.25;
	double posThreshold = isTargetMoving ? stopThreshold : goThreshold;

	//double maxSpeed = .5;
	double minSpeed = .3;
	double taperStart = 6.0;
	double taperEnd = 3.0;
	//double elevatorSpeed = .1;
	double upElevatorSpeed = 0.8;
	double downElevatorSpeed = 0.3;

	double encoderValue = elevatorMotor->GetSelectedSensorPosition(0)/4096.0;
	double difference = targetPos - encoderValue;
	frc::SmartDashboard::PutString("DB/String 2",std::to_string(difference));

	if(difference > posThreshold){
		//keep moving toward targetPos -> move up
		isTargetMoving = true;
		motorStopCount = -1;
		if (isPID) {
			//set target sensor
			elevatorMotor->Set(ControlMode::Position,targetPos*4096.0);
		} else {
			double actualSpeed = upElevatorSpeed;
			if (difference < taperStart) {
				if (difference < taperEnd) {
					actualSpeed = minSpeed;
				}
				else {
					actualSpeed = minSpeed + ((upElevatorSpeed - minSpeed) * (difference - taperEnd))/(taperStart - taperEnd);
				}
			}

			//start motor

			elevatorMotor->Set(ControlMode::PercentOutput,actualSpeed);
			frc::SmartDashboard::PutString("DB/String 3",std::to_string(actualSpeed));
		}
		//open brake
		elevatorBrake->Set(false);
		frc::SmartDashboard::PutString("DB/String 8","brake off");


	}
	else if(difference < -posThreshold){
		//move down
		isTargetMoving = true;
		motorStopCount = -1;
		if (isPID) {
			//set target sensor
			elevatorMotor->Set(ControlMode::Position,targetPos*4096.0);
		} else {
			//start motor
			double actualSpeed = downElevatorSpeed;
			if (difference < taperStart) {
				if (difference < taperEnd) {
					actualSpeed = minSpeed;
				}
				else {
					actualSpeed = minSpeed + ((downElevatorSpeed - minSpeed) * (difference - taperEnd))/(taperStart - taperEnd);
				}
			}
			elevatorMotor->Set(ControlMode::PercentOutput,-actualSpeed);
		}
		//open brake
		elevatorBrake->Set(false);
		frc::SmartDashboard::PutString("DB/String 8","brake off");
	}
	else{
		isTargetMoving = false;
		if(motorStopCount == -1){
			motorStopCount = 0;
		}
		//stop motor
		//elevatorMotor->Set(ControlMode::PercentOutput,0);
		//close brake
		elevatorBrake->Set(true);
		frc::SmartDashboard::PutString("DB/String 8","brake on");
	}

}

void Elevator::ElevatorMoveUp(){
	if(!targetMode){
		targetPos = (elevatorMotor->GetSelectedSensorPosition(0))/4096.0;
		targetMode = true;
	}
	targetPos += 4.0;
	frc::SmartDashboard::PutString("DB/String 1",std::to_string(targetPos));
}

void Elevator::ElevatorMoveDown(){
	if(!targetMode){
		targetPos = (elevatorMotor->GetSelectedSensorPosition(0))/4096.0;
		targetMode = true;
	}
	targetPos -= 4.0;
	frc::SmartDashboard::PutString("DB/String 1",std::to_string(targetPos));
}

//Move to setpoints
void Elevator::ElevatorGoToInches(double inches){
	ElevatorGoToRevolutions(inches*0.5098);
}
void Elevator::ElevatorGoToFloor(){
	ElevatorGoToInches(0);
}
void Elevator::ElevatorGoToExchange(){
	ElevatorGoToInches(2);
	//Height in inches for exchange (tied to button A)
}
void Elevator::ElevatorGoToSwitch(){
	ElevatorGoToInches(21);
	//Height in inches for switch (tied to button B)
}
void Elevator::ElevatorGoToScale(){
	ElevatorGoToInches(62);
	//Height in inches for scale (tied to button X)
}
void Elevator::ElevatorGoToHighScale(){
	ElevatorGoToInches(74);
	//Height in inches for high scale (tied to button Y)
}

void Elevator::PartyLight(bool isMoving,double encoderValue){
	double switchSpot=66 ;
	double lowScaleSpot=137.5;
	double midScaleSpot=170.5;
	double highScaleSpot=203.5;


	if(encoderValue < switchSpot){
		if(isMoving){
			elevatorLEDs->Set(-.06);
		}
		else{
			elevatorLEDs->Set(.67);
		}


	} else if(encoderValue < lowScaleSpot){
		if(isMoving){
			elevatorLEDs->Set(-.06);
		}
		else{
			elevatorLEDs->Set(.61);
		}


	} else if(encoderValue < midScaleSpot){
		if(isMoving){
			elevatorLEDs->Set(-.06);
		}
		else{
			elevatorLEDs->Set(-.09);
		}
	} else if(encoderValue < highScaleSpot){
		if(isMoving){
			elevatorLEDs->Set(-.06);
		}
		else{
			elevatorLEDs->Set(.71);
		}
	} else {
		if(isMoving){
			elevatorLEDs->Set(-.06);
		}
		else{
			elevatorLEDs->Set(.71);

		}
	}
}
void Elevator::SetPIDs(){
	std::string pstring = frc::SmartDashboard::GetString("DB/String 5", "0.05");
	double pdouble = 0.05;
	/*When the p-value is too large it moves very jumpy. A larger p-value increases the strength of the motor.
	 *When it is too low it won't even reach the target location.
	 */
	if (pstring.length() > 0) {
		pdouble = std::stod(pstring);
		}
	std::string istring = frc::SmartDashboard::GetString("DB/String 6", "0.0");
	double idouble = 0;
	/*The i-value must be pretty small. A large i-value causes the i-value to oscillate greatly.
	 * If the i-value is too small it takes a very long time to reach the target location.
	 */
	if (istring.length() > 0) {
		idouble = std::stod(istring);
		}
	std::string dstring = frc::SmartDashboard::GetString("DB/String 7", "0.0");
	double ddouble = 0;
	/*Putting the d-value to 100 freaked out the motor. D-value appears to make the motor less jumpy.
	 * Further testing is needed to see how high the d-value can be
	 */
	if (dstring.length() > 0) {
		ddouble = std::stod(dstring);
		}
	/* set closed loop gains in slot0 */
	elevatorMotor->Config_kF(kPIDLoopIdx, 0, kTimeoutMs);
	elevatorMotor->Config_kP(kPIDLoopIdx, pdouble, kTimeoutMs);
	elevatorMotor->Config_kI(kPIDLoopIdx, idouble, kTimeoutMs);
	elevatorMotor->Config_kD(kPIDLoopIdx, ddouble, kTimeoutMs);
}
