// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "ctre/Phoenix.h"
#include "DriveBaseConstants.h"


#include "DriveBase.h"
#include "../RobotMap.h"
#include "../Robot.h"

#include <math.h>

#define max(x, y) (((x) > (y)) ? (x) : (y))

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

DriveBase::DriveBase() : frc::Subsystem("DriveBase") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    leftMotor2 = RobotMap::driveBaseLeftMotor2;
    rightMotor2 = RobotMap::driveBaseRightMotor2;
    compressor = RobotMap::driveBaseCompressor;
    shiftSolenoid = RobotMap::driveBaseShiftSolenoid;
    pressureSensor = RobotMap::driveBasePressureSensor;
    leftMotor1 = RobotMap::driveBaseLeftMotor1;
    rightMotor1 = RobotMap::driveBaseRightMotor1;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    leftMotor2->Set(ControlMode::Follower,2);
    rightMotor2->Set(ControlMode::Follower,4);
    leftMotor1->SetInverted(false);
    leftMotor2->SetInverted(false);
    rightMotor1->SetInverted(true);
    rightMotor2->SetInverted(true);

	std::string _sb;
	std::string _Rsb;
	//int _loops = 0;
	//bool _lastButton1 = false;
	/** save the target position to servo to */
	//double targetPositionRotations;


	/* choose the sensor and sensor direction */
			leftMotor1->ConfigSelectedFeedbackSensor(
					FeedbackDevice::CTRE_MagEncoder_Relative, kPIDLoopIdx,
					kTimeoutMs);
			leftMotor1->SetSensorPhase(false);

			/* choose the sensor and sensor direction */
			rightMotor1->ConfigSelectedFeedbackSensor(
					FeedbackDevice::CTRE_MagEncoder_Relative, kPIDLoopIdx,
					kTimeoutMs);
			rightMotor1->SetSensorPhase(false);

			/* set the peak and nominal outputs, 12V means full */
			leftMotor1->ConfigNominalOutputForward(0, kTimeoutMs);
			leftMotor1->ConfigNominalOutputReverse(0, kTimeoutMs);
			leftMotor1->ConfigPeakOutputForward(0.5, kTimeoutMs);
			leftMotor1->ConfigPeakOutputReverse(-0.5, kTimeoutMs);

			/* set closed loop gains in slot0 */
			leftMotor1->Config_kF(kPIDLoopIdx, 0.0, kTimeoutMs);
			leftMotor1->Config_kP(kPIDLoopIdx, 0.1, kTimeoutMs);
			leftMotor1->Config_kI(kPIDLoopIdx, 0.0, kTimeoutMs);
			leftMotor1->Config_kD(kPIDLoopIdx, 0.0, kTimeoutMs);

			/* set the peak and nominal outputs, 12V means full */
			rightMotor1->ConfigNominalOutputForward(0, kTimeoutMs);
			rightMotor1->ConfigNominalOutputReverse(0, kTimeoutMs);
			rightMotor1->ConfigPeakOutputForward(0.5, kTimeoutMs);
			rightMotor1->ConfigPeakOutputReverse(-0.5, kTimeoutMs);

			/* set closed loop gains in slot0 */
			rightMotor1->Config_kF(kPIDLoopIdx, 0.0, kTimeoutMs);
			rightMotor1->Config_kP(kPIDLoopIdx, 0.1, kTimeoutMs);
			rightMotor1->Config_kI(kPIDLoopIdx, 0.0, kTimeoutMs);
			rightMotor1->Config_kD(kPIDLoopIdx, 0.0, kTimeoutMs);



}

void DriveBase::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void DriveBase::Periodic() {
    // Put code here to be run every loop

}


// Put methods for controlling this subsystem
// here. Call these from Commands.

void DriveBase::DriveWithJoysticks() {
	//leftMotor1->Set(-1*Robot::oi->getDriveStick()->GetY());
	//rightMotor1->Set(-1*Robot::oi->getDriveStick()->GetY());
	Robot::driveBase->ArcadeDrive(-1*Robot::oi->getDriveStick()->GetY(),-1*Robot::oi->getDriveStick()->GetX());
}

double DriveBase::SensorReading() {
	double a1 = ((pressureSensor->GetVoltage())*50)-25;
	double a2 = (ceil(a1*100))/100;
	return a2;
}

void DriveBase::AutoShift(double upshift, double downshift){
	double motorVelocity = leftMotor1->GetSensorCollection().GetQuadratureVelocity();
		bool isHigh = shiftSolenoid->Get();
		int rpm = ((motorVelocity*10)/4096)*60;
		rpm = abs(rpm);
		SmartDashboard::PutNumber("RPM: ", rpm);

		if(isHigh == false && rpm > upshift){
			shiftSolenoid->Set(true);
		}

		if(isHigh == true && rpm < downshift){
			shiftSolenoid->Set(false);
		}
}

void DriveBase::ShiftingInfo(){
	SmartDashboard::PutNumber("Upshift", 1000);
	SmartDashboard::PutNumber("Downshift", 750);
}

void DriveBase::ArcadeDrive(float moveValue, float rotateValue){
	float leftMotorOutput;
	float rightMotorOutput;
	moveValue = Limit(moveValue);
	if (moveValue > 0.0)
	{
			if (rotateValue > 0.0)
			{
				leftMotorOutput = moveValue - rotateValue;
				rightMotorOutput = max(moveValue, rotateValue);

			}
			else
			{
				leftMotorOutput = max(moveValue, -rotateValue);
				rightMotorOutput = moveValue + rotateValue;
			}
		}
		else
		{
			if (rotateValue > 0.0)
			{

				leftMotorOutput = - max(-moveValue, rotateValue);
				rightMotorOutput = moveValue + rotateValue;
			}
			else
			{

				leftMotorOutput = moveValue - rotateValue;
				rightMotorOutput = - max(-moveValue, -rotateValue);
			}
		}
		leftMotor1->Set(leftMotorOutput);
		rightMotor1->Set(rightMotorOutput);
}

float DriveBase::Limit(float num)
{
	if (num > 1.0)
	{
		return 1.0;
	}
	if (num < -1.0)
	{
		return -1.0;
	}
	return num;

}
void DriveBase::EncoderReset(){
	int absolutePosition = leftMotor1->GetSelectedSensorPosition(0) & 0xFFF; /* mask out the bottom12 bits, we don't care about the wrap arounds */
	/* use the low level API to set the quad encoder signal */
	leftMotor1->SetSelectedSensorPosition(absolutePosition, kPIDLoopIdx, kTimeoutMs);

	/* lets grab the 360 degree position of the MagEncoder's absolute position */
	int RabsolutePosition = rightMotor1->GetSelectedSensorPosition(0) & 0xFFF; /* mask out the bottom12 bits, we don't care about the wrap arounds */
	/* use the low level API to set the quad encoder signal */
	rightMotor1->SetSelectedSensorPosition(RabsolutePosition, kPIDLoopIdx, kTimeoutMs);
}

void DriveBase::AutoDrive(){
		double targetPositionRotations = 1* 10.0 * 4096; /* 50 Rotations in either direction */
		leftMotor1->Set(ControlMode::Position, targetPositionRotations); /* 50 rotations in either direction */
		rightMotor1->Set(ControlMode::Position, targetPositionRotations); /* 50 rotations in either direction */
		//leftMotor1->Set(ControlMode::PercentOutput, .5);
		//rightMotor1->Set(ControlMode::PercentOutput, .5);






	/* if Talon is in position closed-loop, print some more info */
	/*if (leftMotor1->GetControlMode() == ControlMode::Position) {
		// append more signals to print when in speed mode. */
		/*_sb.append("\terrNative:");
		_sb.append(std::to_string(leftMotor1->GetClosedLoopError(kPIDLoopIdx)));
		_sb.append("\ttrg:");
		_sb.append(std::to_string(targetPositionRotations));
		_Rsb.append("\terrNative:");
		_Rsb.append(std::to_string(rightMotor1->GetClosedLoopError(kPIDLoopIdx)));
		_Rsb.append("\ttrg:");
		_Rsb.append(std::to_string(targetPositionRotations));
	}*/

	/* print every ten loops, printing too much too fast is generally bad for performance */
/*	if (++_loops >= 10) {
		_loops = 0;
		printf("%s\n", _sb.c_str());
		printf("%s\n", _Rsb.c_str());
	}*/


}

