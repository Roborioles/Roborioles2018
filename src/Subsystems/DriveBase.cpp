// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "ctre/Phoenix.h"


#include "DriveBase.h"
#include "../RobotMap.h"
#include "../Robot.h"
#include <math.h>
#define max(x, y) (((x) > (y)) ? (x) : (y))

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

DriveBase::DriveBase() : frc::Subsystem("DriveBase") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    leftMotor1 = RobotMap::driveBaseLeftMotor1;
    leftMotor2 = RobotMap::driveBaseLeftMotor2;
    rightMotor1 = RobotMap::driveBaseRightMotor1;
    rightMotor2 = RobotMap::driveBaseRightMotor2;
    compressor = RobotMap::driveBaseCompressor;
    shiftSolenoid = RobotMap::driveBaseShiftSolenoid;
    pressureSensor = RobotMap::driveBasePressureSensor;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    leftMotor2->Set(ControlMode::Follower,2);
    rightMotor2->Set(ControlMode::Follower,4);
    leftMotor1->SetInverted(false);
    leftMotor2->SetInverted(false);
    rightMotor1->SetInverted(true);
    rightMotor2->SetInverted(true);
}

void DriveBase::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void DriveBase::Periodic() {
    // Put code here to be run every loop

}


// Put methods for controlling this subsystem
// here. Call these from Commands.

void DriveBase::DriveWithJoysticks() {
	//leftMotor1->Set(-1*Robot::oi->getDriveStick()->GetY());
	//rightMotor1->Set(-1*Robot::oi->getDriveStick()->GetY());
	Robot::driveBase->ArcadeDrive(-1*Robot::oi->getDriveStick()->GetY(),-1*Robot::oi->getDriveStick()->GetX());
}

double DriveBase::SensorReading() {
	double a1 = ((pressureSensor->GetVoltage())*50)-25;
	double a2 = (ceil(a1*100))/100;
	return a2;
}

void DriveBase::AutoShift(double upshift, double downshift){
	double motorVelocity = leftMotor1->GetSensorCollection().GetQuadratureVelocity();
		bool isHigh = shiftSolenoid->Get();
		int rpm = ((motorVelocity*10)/4096)*60;
		rpm = abs(rpm);
		SmartDashboard::PutNumber("RPM: ", rpm);

		if(isHigh == false && rpm > upshift){
			shiftSolenoid->Set(true);
		}

		if(isHigh == true && rpm < downshift){
			shiftSolenoid->Set(false);
		}
}

void DriveBase::ShiftingInfo(){
	SmartDashboard::PutNumber("Upshift", 1000);
	SmartDashboard::PutNumber("Downshift", 750);
}

void DriveBase::ArcadeDrive(float moveValue, float rotateValue){
	float leftMotorOutput;
	float rightMotorOutput;
	moveValue = Limit(moveValue);
	if (moveValue > 0.0)
	{
			if (rotateValue > 0.0)
			{
				leftMotorOutput = moveValue - rotateValue;
				rightMotorOutput = max(moveValue, rotateValue);

			}
			else
			{
				leftMotorOutput = max(moveValue, -rotateValue);
				rightMotorOutput = moveValue + rotateValue;
			}
		}
		else
		{
			if (rotateValue > 0.0)
			{

				leftMotorOutput = - max(-moveValue, rotateValue);
				rightMotorOutput = moveValue + rotateValue;
			}
			else
			{

				leftMotorOutput = moveValue - rotateValue;
				rightMotorOutput = - max(-moveValue, -rotateValue);
			}
		}
		leftMotor1->Set(leftMotorOutput);
		rightMotor1->Set(rightMotorOutput);
}

float DriveBase::Limit(float num)
{
	if (num > 1.0)
	{
		return 1.0;
	}
	if (num < -1.0)
	{
		return -1.0;
	}
	return num;

}
